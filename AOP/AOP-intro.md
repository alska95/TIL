# AOP

### 포인트컷, 어드바이스, 어드바이저 -소개

**포인트컷** : 어디에 부가 기능을 적용할지, 어디에 부가 기능을 적용할지 않을지 판단하는 필터링 로직이다. 주로 클래스와 메서드 이름으로 필터링 한다. 이름 그대로 어떤 포인트에 기능을 적용할지 하지 않을지 잘라서(point cut) 구분하는 것이다.

**어드바이스** : 프록시가 호출하는 부가 기능이다. 단순하게 프록시 로직이라 생각하면 된다. (addAdvice())

**어드바이저** : 단순하게 하나의 포인트컷과 하나의 어드바이스를 가지고 있는 것이다. 쉽게 이야기해서 ***포인트컷 + 어드바이스*** 이다.

**정리**
* 포인트컷 - 어디
* 어드바이스 - 뭘
* 어드바이저 - 어디에 뭘


### 빈 후처리기

`@Bean`이나 컴포넌트 스캔으로 스프링 빈을 등록하면, 스프링은 대상 객체를 생성하고 스프링 컨테이너 내부의 빈 저장소에 등록한다. 그리고 이후에는 스프링 컨테이너를 통해 등록한 스프링 빈을 조회해서 사용하면 된다.

**빈 후처리기 - BeanPostProcessor**  
스프링이 빈 저장소에 등록할 목적으로 생성한 객체를 빈 저장소에 등록하기 직전에 조작하고 싶다면 빈 후처리기를 사용하면 된다. 빈 포스트 프로세서는 번역하면 빈 후처리기인데, 일므 그대로 빈을 생성한 후에 무언가를 처리하는 용도로 사용한다.  
**빈 후처리기 기능**  
빈 후처리기의 기능은 막강하다. 객체를 조작할 수도 있고, 완전히 다른 객체로 바꿔치기 하는 것도 가능하다.
![](https://i.imgur.com/qgz2aHt.png)

1. 생성 : 스프링 빈 대상이 되는 객체를 생성한다(@Bean, 컴포넌트 스캔 모두 포함)
2. 전달 : 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
3. 후 처리 작업 : 빈 후처리기는 전달된 스프링 빈 객체를 조작하거나 다른 객체로 바꿔치기 할 수 있다.
4. 등록 : 빈 후처리기는 빈을 반환한다. 전달된 빈을 그대로 반환하면 해당 빈이 등록되고, 바꿔치기 하면 다른 객체가 빈 저장소에 등록된다.
![](https://i.imgur.com/oWthdaD.png)


#### 정리
빈 후처리기는 빈을 조작하고 변경할 수 있는 후키 포인트이다. 이것은 빈 객체를 조작하거나 심지어 다른 객체로 변경할 수 있을 정도로 막강하다. 여기서 조작이라는 것은 해당 객체의 특정 메서드를 호출하는 것을 뜻한다. 일반적으로 스프링 컨테이너가 등록하는, 특히 컴포넌트 스캔의 대상이 되는 빈들은 중간에 조작할 방법이 없는데, 빈 후처리기를 사용하면 개발자가 등록하는 모든 빈을 중간에 조작할 수 있다. 이 말은 빈 객체를 **프록시로 교체**하는 것도 가능하다는 뜻이다.

**참고 - @PostConstruct의 비밀**

@PostConstruct는 스프링 빈 생성 이후에 빈을 초기화 하는 역할을 한다. 근데 생각해보면 빈의 초기화 라는 것이 단순히 @PostConstruct어노테이션이 붙은 초기화 매서드를 한번 호출만 하면 된다. 쉽게 이야기해서 생성된 빈을 한번 조작하는 것이다. 따라서 빈을 조작하는 행위를 하는 적절한 빈 후처리기가 있으면 될 것 같다. 스프링은 `CommonAnnotationBeanPostProcessor`라는 빈 후처리기를 자동으로 등록하는데, 여기에서 @PostConstruct어노테이션이 붙은 메서드를 호출한다. 따라서 스프링 스스로도 스프링 내부의 기능을 확장하기 위해 빈 후처리기를 사용한다.

### 스프링 aop가 제공하는 빈 후처리기
스프링 부트가 없던 시절에는 @EnableAspectJAutoProxy를 직접 사용해야 했는데, 이 부분을 스프링 부트가 자동으로 처리해준다. Advisor는 물론이고, @Aspect도 자동으로 인식해서 프록시를 만들고 AOP를 적용해준다. @Aspect에 대한 자세한 내용은 뒤에 설명한다.

***자동 프록시 생성기의 작동 과정***
1.생성: 스프링이 스프링 빈 대상이 되는 객체를 생성한다 (@Bean, 컴포넌트 스캔 모두 포함)  
2.전달: 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.  
3.모든 Advisor 빈 조회: 자동 프록시 생성기 - 빈 후처리기는 스프링 컨테이너에서 모든 advisor을 조회한다.  
4.프록시 적용 대상 체크: 앞서 조회한 `Advisor`에 포함되어 있는 포인트컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단한다. 이때 객체의 클래스 정보는 물론이고, 해당 객체의 모든 메서드를 포인트컷에 하나하나 모두 매칭해본다. 그래서 조건이 하나더라도 만족하면 프록시 적용 대상이 된다. 예를 들어서 **10개의 메서드 중에 하나만 포인트컷 조건에 만족해도 프록시 적용 대상이 된다.**
5.프록시 생성: 프록시 적용 대상이면 프록시를 생성하고 반환해서 프록시를 스프링 빈으로 등록한다. 만약 대상이 아니라면 원본 객체를 반환한다.
6.빈 등록: 반환된 객체는 스프링 빈으로 등록된다.


**case : 스프링 빈이 여러개의 포인트 컷을 만족하는 경우**
만족하는 개수 만큼 프록시가 생성되는 것이 아니라, 하나의 프록시가 생성되고 여러개의 어드바이저가 적용된다. 프록시가 여러개 생성되서 비용을 낭비할 이유가 없음
***이후에 설명할 aop도 동일한 방식으로 동작한다!*** 
![](https://i.imgur.com/20k5BjF.png)


### @Aspect 프록시 -적용

스프링 애플리케이션에 프록시를 적용하려면 포인트컷과 어드바이스로 구성되어 있는 어드바이저(advisor)를 만들어서 스프링 빈으로 등록하게 된다. 그러면 나머지는 앞서 배운 자동 프록시 생성기가 몯 ㅜ자동으로 처리해준다. 자동 프록시 생성기는 스프링 빈으로 등록된 어드바이저들을 찾고, 스프링 빈들에게 자동으로 프록시를 적용해 준다.

스프링은 ***@Aspect***어노테이션으로 매우 편리하게 포인트컷과 어드바이스로 구성되어 있는 어드바이저 생성 기능을 지원한다.  
지금까지 어드바이저를 직접 만들었던 부분을 ***@Aspect***어노테이션을 사용해서 만들어보자.  

**참고:**@Aspect는 관점 지향 프로그래밍(AOP)을 가능하게 하는 AspectJ 프로젝트에서 제공하는 어노테이션이다. 스프링은 이것을 차용해서 프록시를 통한 AOP를 가능하게 한다.  

***설명***
앞서 자동 프록시 생성기를 학습할 때, 자동 프록시 생성기(AnnotationAwareAspectJAutoProxyCreator)는 Advisor를 자동으로 찾아와서 필요한 곳에 프록시를 생성하고 적용해준다고 했다. 자동 프록시 생성기는 여기에 추가로 하나의 역할을 더 하는데, 바로 @Aspect를 찾아서 이것을 Advisor로 만들어준다. 쉽게 이야기해서 지금까지 학습한 기능에 @Aspect를 @Advisor로 변환해서 저장하는 기능도 한다. 그래서 이름 앞에 AnnotationAware가 붙어 있는 것이다.   


***자동 프록시 생성기 - @Aspect 어드바이저 적용***  
1.생성 : 스프링 빈 대상이 되는 객체를 생성한다. (@Bean, 컴포넌트 스캔 모두 포함)
2.전달: 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
3-1.Advisor 빈 조회 : 스프링 컨테이너에서 advisor빈을 모두 조회한다.  
3-2.@Aspect Advisor조회 : @Aspect 어드바이저 빌더 내부에 저장된 Advisor를 모두 조회한다.
4.프록시 적용 대상 체크: 앞서 3-1, 3-2에서 조회한 advisor에 포함되어 있는 포인트컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단한다.
이때 객체의 클래스 정보는 물론이고, 해당 객체의 모든 메서드를 포인트컷 하나하나에 모두 매칭해본다. 그래서 조건이 하나라도 만족하면 프록시 적용 대상이 된다. 예를 들어서 메서드 하나만 포인트컷 조건에 만족해도 프록시 적용 대상이 된다.
5.프록시 생성: 프록시 적용 대상이면 프록시를 생성하고 프록시를 반환한다. 그래서 프록시를 스프링 빈으로 등록한다. 만약 프록시 적용 대상이 아니라면 원본 객체를 반환해서 원본 객체를 스프링 빈으로 등록한다.
6.빈 등록: 반환된 객체는 스프링 빈으로 등록된다.

@Aspect를 보고 advisor을 만든다. advisor을 만드는데 @Around의 포인트컷 정보를 참고, 함수 로직을 advice로 사용.



### AOP소개 
***핵심 기능과 부가기능***  
* 핵심 기능은 해당 객체가 제공하는 고유의 기능이다. EX) 주문로직
* 부가 기능은 핵심 기능을 보조하기 위해 제공되는 기능이다. 예를 들어서 로그 추적, 트랜잭션 기능이 있다. 이러한 부가 기능은 단독으로 사용되지 않고, 핵심 기능과 함께 사용된다. 예를 들어서 로그 추적 기능은 어떤 핵심 기능이 호출되었는지 로그를 남기기 위해 사용된다. 그러니까 부가 기능은 이름 그대로 핵심 기능을 보조하기 위해 존재한다. 

***여러 곳에서 공통으로 사용하는 부가 기능***  
보통 부가 기능은 여러 클래스에 걸쳐서 함께 사용된다. 예를 들어서 모든 애플리케이션 호출을 로깅 해야 하는 요구사항을 생각해보자.
이러한 부가 기능은 횡단 관심사(cross-cutting concerns)가 된다. 쉽게 이야기해서 하나의 부가 기능이 여러 곳에 동일하게 사용된다는 뜻이다.  

***부가 기능 적용 문제***  
그런데 이런 부가 기능을 여러 곳에 적용하려면 너무 번거롭다. 예를 들어서 부가 기능을 적용해야 하는 클래스가 100개면 100개 모두에 동일한 코드를 추가해야 한다.

***부가 기능 문제 정리***  
* 아주 많은 반복이 필요
* 부가 기능이 여러곳에 퍼져서 중복 코드를 만들어냄
* 수정할때 중복된 부분 모두 고쳐줘야함.
* 적용 대상을 변경할때 많은 수정이 필요하다.
--> 이걸 해결하기 위한 방법이 **AOP**

### AOP 소개 - ASPECT
***핵심 기능과 부가 기능을 분리***
누군가는 이러한 부가 기능 도입의 문제점들을 해결하기 위해 오랜기간 고민해왔다. 그 결과 부가 기능을 핵심기능에서 분리하고 한 곳에서 관리하도록 했다. 그리고 해당 부가 기능을 어디에 적용할지 선택하는 기능도 만들었다. 이렇게 부가 기능과 부가 기능을 어디에 적용할지 선택하는 기능을 합해서 하나의 모듈로 만들었는데 이것이 바로 애스팩트(aspect)이다. aspect는 쉽게 이야기해서 부가 기능과, 해당 부가 기능을 어디에 적용할지 정의한 것이다. 예를 들어서 로그 출력 기능을 모든 컨트롤러에 적용해라 라는 것이 정의되어 있다.
@Aspect가 바로 그것이다. 그리고 스프링이 제공하는 어드바이저도 어드바이스와 포인트컷을 가지고 있어서 개념상 하나의 어스팩트 이다. aspect는 우리말로 해석하면 관점이라는 뜻인데, 이름 그대로 애플리케이션이 바라보는 관점을 하나하나의 기능에서 횡단 관심사 관점으로 달리 보는 것이다. 이렇게 **애스펙트를 사용한 프로그래밍 방식을 관점 지향 프로그래밍 AOP(aspect oriented programming)이라고 한다.**  
* 참고로 AOP는 OOP를 대체하기 위한 것이 아니라 횡단 관심사를 깔끔하게 처리하기 어려운 OOP의 부족한 부분을 보조하는 목적으로 개발되었다.

***ASPECTJ 프레임워크 (여기서 j는 java)***  
AOP의 대표적인 구현으로 AspectJ 프레임워크가 있다. 물론 스프링도 AOP를 지원하지만 대부분 AspectJ의 문법을 차용하고, AspectJ가 제공하는 기능의 일부만 제공한다.
AspectJ 프래임워크는 스스로를 다음과 같이 설명한다
* 자바 프로그래밍 언어에 대한 완벽한 관점 지향 확장
* 횡단 관심사의 깔끔한 모듈화
    * 오류 검사 및 처리
    * 동기화
    * 성능 최적화(캐싱)
    * 모니터링 및 로깅

AOP를 사용하면 핵심 기능과 부가 기능이 코드상 완전히 분리되어서 관리된다.
그렇다면 AOP를 사용할 때 부가 기능 로직은 어떤 방식으로 실제 로직에 추가될 수 있을까?
**크게 3가지 방법이 있다.**
* 컴파일 시점
* 클래스 로딩 시점
* 런타임 시점(프록시)  

**1. 컴파일 시점**
`.java` 소스 코드를 컴파일러를 사용해서 `.class`를 만드는 시점에 부가 기능 로직을 추가할 수 잇다. 이때는 AspectJ가 제공하는 특별한 컴파일러를 사용해야 한다. 컴파일 된 .class를 디컴파일 해보면 에스팩트 관련 호출 코드가 들어간다. 이해하기 쉽게 풀어서 이야기하면 부가 기능 코드가 핵심 기능이 있는 컴파일된 코드 주변에 실제로 붙어 버린다고 생각하면 된다. AspectJ 컴파일러는 Aspect를 확인해서 해당 클래스가 적용 대상인지 먼저 확인하고, 적용 대상인 경우에 부가 기능 로직을 적용한다. 참고로 이렇게 원본 로직에 부가 기능 로직이 추가되는 것을 위빙이라 한다.  
위빙 : 옷감을 짜다. 직조하다. 애스팩트와 실제 코드를 연결해서 붙이는 것.
* 단점 : 컴파일 시점에 부가 기능을 적용하려면 특별한 컴파일러도 필요하고 복잡하다.



***스프링 AOP 적용 위치***
AOP는 지금까지 학습한 메서드 질행 위치 뿐만 아니라 다음과 같은 다양한 위치에 적용할 수 있다.
(생성자, 필드 값 접근, static 메서드 접근, 메서드 실행) 이렇게 AOP를 적용할 수 있는 지점을 조인 포인트(Join point)라 한다.  
AspectJ를 사용해서 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP는 바이트 코드를 실제 조작하기 때문에 해당 기능을 모든 지점에 다 적용할 수 있다.
**but**  
***프록시 방식***을 사용하는 스프링 aop는 메서드 실행 지점에서만 aop를 적용할 수 있다.  

### 참고 - 중요
스프링은 AspectJ의 문법을 차용하고 프록시 방식의 aop를 적용한다. AspectJ를 직접 사용하는 것은 아니다.
스프링이 제공하는 aop는 프록시를 사용한다. 따라서 프록시를 통해 메서드를 실행하는 시점에만 aop가 적용된다.
물론 제약은 있지만 스프링이 제공해 주는것만 해도 충분히 전부 커버할 수 있다.


### AOP - 용어 정리

* Join Point : AOP를 적용할 수 있는 위치
    * 조인 포인트는 추상적인 개념이다. AOP를 적용할 수 있는 모든 지점이라 생각하면 된다.
    * 스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메소드 실행 지점으로 제한된다.
* Pointcut : 조인 포인트 중에서 어드바이스가 적용될 위치 선별
    * 주로 AspectJ 표현식을 사용해서 지정
    * 프록시를 사용하는 스프링 aop는 메서드 실행 지점만 포인트 컷으로 선별 가능.
* target : 어드바이스를 받는 객체, 포인트컷으로 결정 
* advice
    * 부가 기능 로직 담음.
    * 특정 조인 포인트에서 aspect에 의해 취해지는 조치
    * Around(주변), Before(전), After(후)와 같은 다양한 종류의 어드바이스가 있다.
* Aspect
    * 어드바이스 + 포인트컷을 모듈화 한 것
    * @Aspect를 생각하면 된다.
    * 여러 어드바이스와 포인트 컷이 함깨 존재한다.
* Advisor
    * 스프링 aop만 사용
    * pointcut + advice
* weaving
    * 포인트 컷으로 결정한 타겟의 조인포인트에 어드바이스를 적용하는 것
    * 위빙을 통해 핵심 기능 코드에 영향을 주지 않고 부가 기능 추가 가능.
    * aop 적용을 위해 애스팩트를 객체에 연결한 상태
        * 런타임, 프록시
* aop 프록시
    * jdk혹은 cglib사용 가능.  